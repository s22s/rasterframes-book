{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# GeoTrellis Operations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Intitializing Scala interpreter ..."
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "Spark Web UI available at http://172.18.0.2:4041\n",
       "SparkContext available as 'sc' (version = 2.2.0, master = local[*], app id = local-1530810905187)\n",
       "SparkSession available as 'spark'\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "import astraea.spark.rasterframes._\n",
       "import geotrellis.raster._\n",
       "import geotrellis.raster.render._\n",
       "import geotrellis.raster.io.geotiff.SinglebandGeoTiff\n",
       "import org.apache.spark.sql._\n",
       "import org.apache.spark.sql.functions._\n",
       "spark: org.apache.spark.sql.SparkSession = org.apache.spark.sql.SparkSession@48f0a03c\n",
       "import spark.implicits._\n",
       "scene: geotrellis.raster.io.geotiff.SinglebandGeoTiff = SinglebandGeoTiff(geotrellis.raster.UShortConstantNoDataArrayTile@3b0587d8,Extent(431902.5, 4313647.5, 443512.5, 4321147.5),EPSG:32616,Tags(Map(AREA_OR_POINT -> POINT),List(Map())),GeoTiffOptions(geotrellis.raster.io.geotiff.Striped@4931bd7e,geotrellis.raster.io.geotiff.compression.DeflateCompression$@5e1dd8c7,1,None))\n",
       "rf: astraea.spark.rasterframes.RasterFrame = [spatial_key: struct<col: int, row: int>, t..."
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import astraea.spark.rasterframes._\n",
    "import geotrellis.raster._\n",
    "import geotrellis.raster.render._\n",
    "import geotrellis.raster.io.geotiff.SinglebandGeoTiff\n",
    "import org.apache.spark.sql._\n",
    "import org.apache.spark.sql.functions._\n",
    "\n",
    "implicit val spark = SparkSession.builder().\n",
    "  master(\"local[*]\").appName(\"RasterFrames\").getOrCreate().withRasterFrames\n",
    "spark.sparkContext.setLogLevel(\"ERROR\")\n",
    "import spark.implicits._\n",
    "val scene = SinglebandGeoTiff(\"../samples/L8-B8-Robinson-IL.tiff\")\n",
    "val rf = scene.projectedRaster.toRF(128, 128)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "GeoTrellis provides a [rich set of Map Algebra operations](https://docs.geotrellis.io/en/latest/guide/core-concepts.html#map-algebra) and other tile processing features that can be used with RasterFrames via Spark's UDF support.\n",
    "\n",
    "Here's an example creating a UDFs to invoke the `equalize` transformation on each tile in a RasterFrame, and then compute the resulting per-tile mean of it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "+------------------+\n",
      "|equalizedMean     |\n",
      "+------------------+\n",
      "|32634.257767197705|\n",
      "|32777.45174876396 |\n",
      "|32775.68302508698 |\n",
      "|32881.48989806507 |\n",
      "|32776.88976377953 |\n",
      "+------------------+\n",
      "only showing top 5 rows\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "import geotrellis.raster.equalization._\n",
       "equalizer: org.apache.spark.sql.expressions.UserDefinedFunction = UserDefinedFunction(<function1>,org.apache.spark.sql.gt.types.TileUDT@67300a29,Some(List(org.apache.spark.sql.gt.types.TileUDT@67300a29)))\n",
       "equalized: org.apache.spark.sql.DataFrame = [equalized: rf_tile]\n"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import geotrellis.raster.equalization._\n",
    "val equalizer = udf((t: Tile) => t.equalize())\n",
    "val equalized = rf.select(equalizer($\"tile\") as \"equalized\")\n",
    "equalized.select(tileMean($\"equalized\") as \"equalizedMean\").show(5, false)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Here's an example downsampling a tile and rendering each tile as a matrix of numerical values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "+-------------------+\n",
      "|minime             |\n",
      "+-------------------+\n",
      "|∘∘∘∘\n",
      "∘∘∘∘\n",
      "∘∘∘∘\n",
      "∘∘∘∘|\n",
      "|.%*+\n",
      "=@=@\n",
      "#+:#\n",
      ":-  |\n",
      "|#:.%\n",
      "* + \n",
      "=:-@\n",
      "@#=+|\n",
      "|-+%=\n",
      ":*:.\n",
      "=+ @\n",
      "#@ #|\n",
      "|-:*+\n",
      ".=-.\n",
      " +@#\n",
      "%.@#|\n",
      "+-------------------+\n",
      "only showing top 5 rows\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "downsample: org.apache.spark.sql.expressions.UserDefinedFunction = UserDefinedFunction(<function1>,org.apache.spark.sql.gt.types.TileUDT@67300a29,Some(List(org.apache.spark.sql.gt.types.TileUDT@67300a29)))\n",
       "downsampled: org.apache.spark.sql.DataFrame = [minime: string]\n"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "val downsample = udf((t: Tile) => t.resample(4, 4))\n",
    "val downsampled = rf.select(renderAscii(downsample($\"tile\")) as \"minime\")\n",
    "downsampled.show(5, false)\n",
    "\n",
    "spark.stop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "spylon-kernel",
   "language": "scala",
   "name": "spylon-kernel"
  },
  "language_info": {
   "codemirror_mode": "text/x-scala",
   "file_extension": ".scala",
   "help_links": [
    {
     "text": "MetaKernel Magics",
     "url": "https://github.com/calysto/metakernel/blob/master/metakernel/magics/README.md"
    }
   ],
   "mimetype": "text/x-scala",
   "name": "scala",
   "pygments_lexer": "scala",
   "version": "0.4.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
